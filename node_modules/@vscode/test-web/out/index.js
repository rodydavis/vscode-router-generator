#!/usr/bin/env node
"use strict";
/* eslint-disable header/header */
Object.defineProperty(exports, "__esModule", { value: true });
exports.open = exports.runTests = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const main_1 = require("./server/main");
const download_1 = require("./server/download");
const playwright = require("playwright");
const minimist = require("minimist");
const path = require("path");
/**
 * Runs the tests in a browser.
 *
 * @param options The options defining browser type, extension and test location.
 */
async function runTests(options) {
    const config = {
        extensionDevelopmentPath: options.extensionDevelopmentPath,
        extensionTestsPath: options.extensionTestsPath,
        build: await getBuild(options.version),
        folderUri: options.folderUri,
        folderMountPath: options.folderPath,
        hideServerLog: true,
        extensionPaths: options.extensionPaths
    };
    const port = 3000;
    const server = await (0, main_1.runServer)(port, config);
    return new Promise(async (s, e) => {
        const endpoint = `http://localhost:${port}`;
        const context = await openBrowser(endpoint, options);
        context.once('close', () => server.close());
        await context.exposeFunction('codeAutomationLog', (type, args) => {
            console[type](...args);
        });
        await context.exposeFunction('codeAutomationExit', async (code) => {
            var _a;
            try {
                await ((_a = context.browser()) === null || _a === void 0 ? void 0 : _a.close());
            }
            catch (error) {
                console.error(`Error when closing browser: ${error}`);
            }
            server.close();
            if (code === 0) {
                s();
            }
            else {
                e(new Error('Test failed'));
            }
        });
    });
}
exports.runTests = runTests;
async function getBuild(version) {
    if (version === 'sources') {
        return { type: 'sources' };
    }
    return await (0, download_1.downloadAndUnzipVSCode)(version === 'stable' ? 'stable' : 'insider');
}
async function open(options) {
    const config = {
        extensionDevelopmentPath: options.extensionDevelopmentPath,
        extensionTestsPath: options.extensionTestsPath,
        build: await getBuild(options.version),
        folderUri: options.folderUri,
        folderMountPath: options.folderPath,
        extensionPaths: options.extensionPaths
    };
    const port = 3000;
    const server = await (0, main_1.runServer)(port, config);
    const endpoint = `http://localhost:${port}`;
    const context = await openBrowser(endpoint, options);
    context.once('close', () => server.close());
    return {
        dispose: () => {
            var _a;
            server.close();
            (_a = context.browser()) === null || _a === void 0 ? void 0 : _a.close();
        }
    };
}
exports.open = open;
const width = 1200;
const height = 800;
async function openBrowser(endpoint, options) {
    var _a, _b;
    const args = [];
    if (process.platform === 'linux' && options.browserType === 'chromium') {
        args.push('--no-sandbox');
    }
    if (options.waitForDebugger) {
        args.push(`--remote-debugging-port=${options.waitForDebugger}`);
    }
    const headless = (_a = options.headless) !== null && _a !== void 0 ? _a : options.extensionDevelopmentPath !== undefined;
    const browser = await playwright[options.browserType].launch({ headless, args, devtools: options.devTools });
    const context = await browser.newContext();
    if (options.permissions) {
        context.grantPermissions(options.permissions);
    }
    // forcefully close browser if last page is closed. workaround for https://github.com/microsoft/playwright/issues/2946
    let openPages = 0;
    context.on('page', page => {
        openPages++;
        page.once('close', () => {
            openPages--;
            if (openPages === 0) {
                browser.close();
            }
        });
    });
    const page = (_b = context.pages()[0]) !== null && _b !== void 0 ? _b : await context.newPage();
    if (options.waitForDebugger) {
        await page.waitForFunction(() => '__jsDebugIsReady' in globalThis);
    }
    await page.setViewportSize({ width, height });
    await page.goto(endpoint);
    return context;
}
function validateStringOrUndefined(options, name) {
    const value = options[name];
    if (value === undefined || (typeof value === 'string')) {
        return value;
    }
    console.log(`'${name}' needs to be a string value.`);
    showHelp();
    process.exit(-1);
}
async function validatePathOrUndefined(options, name, isFile) {
    const loc = validateStringOrUndefined(options, name);
    return loc && validatePath(loc, isFile);
}
function validateBooleanOrUndefined(options, name) {
    const value = options[name];
    if (value === undefined || (typeof value === 'boolean')) {
        return value;
    }
    console.log(`'${name}' needs to be a boolean value.`);
    showHelp();
    process.exit(-1);
}
function valdiateBrowserType(browserType) {
    if (browserType === undefined) {
        return 'chromium';
    }
    if ((typeof browserType === 'string') && ['chromium', 'firefox', 'webkit'].includes(browserType)) {
        return browserType;
    }
    console.log(`Invalid browser type.`);
    showHelp();
    process.exit(-1);
}
function valdiatePermissions(permissions) {
    if (permissions === undefined) {
        return undefined;
    }
    function isValidPermission(p) {
        return typeof p === 'string';
    }
    if (isValidPermission(permissions)) {
        return [permissions];
    }
    if (Array.isArray(permissions) && permissions.every(isValidPermission)) {
        return permissions;
    }
    console.log(`Invalid permission`);
    showHelp();
    process.exit(-1);
}
async function valdiateExtensionPaths(extensionPaths) {
    if (extensionPaths === undefined) {
        return undefined;
    }
    if (!Array.isArray(extensionPaths)) {
        extensionPaths = [extensionPaths];
    }
    if (Array.isArray(extensionPaths)) {
        const res = [];
        for (const extensionPath of extensionPaths) {
            if (typeof extensionPath === 'string') {
                res.push(await validatePath(extensionPath));
            }
            else {
                break;
            }
        }
        return res;
    }
    console.log(`Invalid extensionPath`);
    showHelp();
    process.exit(-1);
}
async function validatePath(loc, isFile) {
    loc = path.resolve(loc);
    if (isFile) {
        if (!await (0, download_1.fileExists)(loc)) {
            console.log(`'${loc}' must be an existing file.`);
            process.exit(-1);
        }
    }
    else {
        if (!await (0, download_1.directoryExists)(loc)) {
            console.log(`'${loc}' must be an existing folder.`);
            process.exit(-1);
        }
    }
    return loc;
}
function validateVersion(version) {
    if (version === undefined || ((typeof version === 'string') && ['insiders', 'stable', 'sources'].includes(version))) {
        return version;
    }
    console.log(`Invalid version.`);
    showHelp();
    process.exit(-1);
}
function validatePortNumber(port) {
    if (typeof port === 'string') {
        const number = Number.parseInt(port);
        if (!Number.isNaN(number) && number >= 0) {
            return number;
        }
    }
    return undefined;
}
function showHelp() {
    console.log('Usage:');
    console.log(`  --browserType 'chromium' | 'firefox' | 'webkit': The browser to launch. [Optional, default 'chromium']`);
    console.log(`  --extensionDevelopmentPath path: A path pointing to an extension under development to include. [Optional]`);
    console.log(`  --extensionTestsPath path: A path to a test module to run. [Optional]`);
    console.log(`  --version 'insiders' | 'stable' | 'sources' [Optional, default 'insiders']`);
    console.log(`  --open-devtools: If set, opens the dev tools  [Optional]`);
    console.log(`  --headless: Whether to hide the browser. Defaults to true when an extensionTestsPath is provided, otherwise false. [Optional]`);
    console.log(`  --hideServerLog: Whether to hide the server log. Defaults to true when an extensionTestsPath is provided, otherwise false. [Optional]`);
    console.log(`  --permission: Permission granted in the opened browser: e.g. 'clipboard-read', 'clipboard-write':  [Optional, Multiple]`);
    console.log(`  --folder-uri: workspace to open VS Code on. Ignored when folderPath is provided [Optional]`);
    console.log(`  --extensionPath: A path pointing to a folder containing additional extensions to include [Optional, Multiple]`);
    console.log(`  folderPath. A local folder to open VS Code on. The folder content will be available as a virtual file system. [Optional]`);
}
async function cliMain() {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const manifest = require('../package.json');
    console.log(`${manifest.name}: ${manifest.version}`);
    const options = {
        string: ['extensionDevelopmentPath', 'extensionTestsPath', 'browserType', 'version', 'waitForDebugger', 'folder-uri', 'permission', 'extensionPath'],
        boolean: ['open-devtools', 'headless', 'hideServerLog', 'help'],
        unknown: arg => {
            if (arg.startsWith('-')) {
                console.log(`Unknown argument ${arg}`);
                showHelp();
                return false;
            }
            return true;
        }
    };
    const args = minimist(process.argv.slice(2), options);
    if (args.help) {
        showHelp();
        process.exit();
    }
    const browserType = valdiateBrowserType(args.browserType);
    const extensionTestsPath = await validatePathOrUndefined(args, 'extensionTestsPath', true);
    const extensionDevelopmentPath = await validatePathOrUndefined(args, 'extensionDevelopmentPath');
    const extensionPaths = await valdiateExtensionPaths(args.extensionPath);
    const version = validateVersion(args.version);
    const devTools = validateBooleanOrUndefined(args, 'open-devtools');
    const headless = validateBooleanOrUndefined(args, 'headless');
    const permissions = valdiatePermissions(args.permission);
    const hideServerLog = validateBooleanOrUndefined(args, 'hideServerLog');
    const waitForDebugger = validatePortNumber(args.waitForDebugger);
    let folderUri = validateStringOrUndefined(args, 'folder-uri');
    let folderPath;
    const inputs = args._;
    if (inputs.length) {
        const input = await validatePath(inputs[0]);
        if (input) {
            folderPath = input;
            if (folderUri) {
                console.log(`Local folder provided as input, ignoring 'folder-uri'`);
                folderUri = undefined;
            }
        }
    }
    if (extensionTestsPath) {
        runTests({
            extensionTestsPath,
            extensionDevelopmentPath,
            browserType,
            version,
            devTools,
            waitForDebugger,
            folderUri,
            folderPath,
            headless,
            hideServerLog,
            permissions,
            extensionPaths
        });
    }
    else {
        open({
            extensionDevelopmentPath,
            browserType,
            version,
            devTools,
            waitForDebugger,
            folderUri,
            folderPath,
            headless,
            hideServerLog,
            permissions,
            extensionPaths
        });
    }
}
if (require.main === module) {
    cliMain();
}
